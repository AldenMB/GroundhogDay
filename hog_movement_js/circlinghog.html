<!DOCTYPE html>
<html>
<head>
<title>Demo Hog Movement</title>
</head>

<style type="text/css">
td{
  color:white;
  background-color:black;
  width:4em;
  height:4em;
  text-align:center;
}
.road{
  background-color:darkred;
}

.looped{
  color:lightgreen;
}
.stuck{
  color:red;
}
</style>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js">
</script>

<script type="text/javascript">

class Tile{
  constructor(board, x, y, floor){
    this.board = board;
    this.x = x;
    this.y = y;
    this.floor = floor;
    this.flans = [];
    this.houses = [];
  }
  appearance(){
    var s=$("<span>");
    for (let house of this.houses){
      s.append(house.appearance());
    };
    for (let flan of this.flans){
      s.append(flan.appearance());
    };
    return s;
  }
  remove_flan(flan){
    var index = this.flans.indexOf(flan);
    if (index > -1) {
      this.flans.splice(index,1);
    };
  }
  remove_house(house){
    var index = this.houses.indexOf(house);
    if (index > -1) {
      this.houses.splice(index,1);
    };
  }
  flan_pointing(direction){
    for (let flan of this.flans){
      if (flan.direction === direction){
        return flan;
      };
    };
    return false;
  }
  flan_going(direction){
    for (let flan of this.flans){
      if (flan.going() === direction){
        return flan;
      };
    };
    return false;
  }
  road_toggle(){
    if(this.floor === ''){
      this.floor = 'r';
    } else {
      this.floor ='';
    }
  }
  house_toggle(){
    if(this.houses.length > 0){
      this.houses[0].deconstruct();
    } else {
      new House(this.board,this.x,this.y,"N");
    }
  }
  on_click(){
    switch (this.board.selected_tool){
      case "rotate_house":
        if(this.houses.length>0)this.houses[0].rotate();
        break;
      case "road_toggle":
        this.road_toggle();
        break;
      case "house_toggle":
        this.house_toggle();
        break;
      default:
        throw "no such tool as "+this.board.selected_tool;
        break;      
    }
    this.board.is_changed = true;
    this.render_update();
  }
  id(){
    return 'tile_'+this.x+'_'+this.y;
  }
  render_update(){
    var td = $('#'+this.id());
    td.empty();
    td.append(this.appearance());
    if (this.floor === 'r'){
      td.addClass('road');
    } else {
      td.removeClass('road');
    }
  }
}

class Board{
  constructor(width,height){
    this.width = width;
    this.height = height;
    this.axes = [...Array(width)].map(e => Array(height).fill(''));
    for(var i=0;i<width;i++){
      for(var j=0;j<height;j++){
        this.axes[i][j]= new Tile(this,i,j,'');
      }
    }
    this.flans = [];
    this.is_changed = false;
    this.number_of_steps = 0;
    this.houses = [];
    this.selected_tool = "road_toggle";
    this.window = new Game_window(this);
    this.frame=0;
  }
  remove_flan(flan){
    var index = this.flans.indexOf(flan);
    if (index > -1) {
      this.flans.splice(index,1);
    };
  }
  remove_house(house){
    var index = this.houses.indexOf(house);
    if (index > -1) {
      this.houses.splice(index,1);
    };
  }
  step(){
    for (let flan of this.flans){
      flan.has_stepped = false;
      flan.hopped_from = false;
      flan.previous_stack_position = flan.stack_position();
    };
    if (this.is_changed){
      for (let flan of this.flans){
        flan.looped = false;
        flan.stuck = false;
      };
      this.is_changed = false;
    };
    for (let flan of this.flans){
      flan.step();
    };
    this.number_of_steps ++;
  }
  recall_flan(){
    for (let house of this.houses){
      house.recall_flan();
    };
  }
  reset_day(){
    this.number_of_steps = 0;
    this.recall_flan();
  }
  
  render(){
    var board_container = $("#board_container")
    var board_table = $("<table>")
    for (var j=this.height-1;j>=0;j--){
      var tr = $("<tr>")
      for (var i=0;i<this.width;i++){
        var td = $("<td>");
        var tile = this.axes[i][j];
        td.attr("id",tile.id());
        if (tile.floor === "r") {
          td.addClass("road")
        }
        td.append(tile.appearance());

        let clickhandlerfactory = function(i,j,board){
          return function(){
            board.axes[i][j].on_click();
          }
        }
        td.bind("click",clickhandlerfactory(i,j,this))
        tr.append(td)
      }
      board_table.append(tr)
    }
    board_container.empty()
    board_container.append(board_table)
    this.update_tool_display();
    this.update_step_display();
    this.window.draw_visible();
  }
  
  update_tool_display(){
    $("#selected_tool").empty().append(`The current tool is ${this.selected_tool}.`);
  }
  update_step_display(){
    $("#step_count").empty().append(`This day has gone on for ${this.number_of_steps} steps.`);
  }
  next_frame(){
    var frames_per_cycle = 60;
    this.frame++
    this.window.shift_step();
    this.window.draw_visible(this.frame / frames_per_cycle);
    if (this.frame >= frames_per_cycle){
      this.frame = 0;
      this.step();
      this.update_step_display();
      for(var i=0;i<this.width;i++){
        for(var j=0;j<this.height;j++){
          this.axes[i][j].render_update();
        }
      }
    }
  }
}
/*
Board.prototype.render = function render(){
  var board_container = $("#board_container")
  var board_table = $("<table>")
  for (var j=this.height-1;j>=0;j--){
    var tr = $("<tr>")
    for (var i=0;i<this.width;i++){
      var td = $("<td>");
      var tile = this.axes[i][j];
      td.attr("id",tile.id());
      if (tile.floor === "r") {
        td.addClass("road")
      }
      td.append(tile.appearance());

      clickhandlerfactory = function(i,j,board){
        return function(){
          board.axes[i][j].on_click();
        }
      }
      td.bind("click",clickhandlerfactory(i,j,this))
      tr.append(td)
    }
    board_table.append(tr)
  }
  board_container.empty()
  board_container.append(board_table)
  this.update_tool_display();
  this.update_step_display();
  this.window.draw_visible();
}
*/
arrows = {
  "N":"↑",
  "E":"→",
  "W":"←",
  "S":"↓"
}

class Flan{
  constructor(board,x,y,direction){
    //variables
    this.x = x;
    this.y = y;
    this.direction = direction;
    this.board = board;
    this.has_stepped = false;
    this.is_waiting = false;
    this.looped = false;
    this.stuck = false;
    this.decorator = '';
    this.hopped_from = false;
    this.previous_stack_position = 0;
    //change other variables upon creation
    board.flans.push(this);
    board.axes[x][y].flans.push(this);
  }
  stack_position(){
    return this.tile().flans.indexOf(this);
  }
  tile(){
    return this.board.axes[this.x][this.y];
  }
  deconstruct(){
    this.tile().remove_flan(this);
    this.board.remove_flan(this);
  }
  appearance(){
    var s = $("<span>");
    s.addClass("flan");
    if(this.looped){
      s.addClass("looped");
    }
    if(this.stuck){
      s.addClass("stuck");
    }
    s.text(arrows[this.direction]+this.decorator);
    return s;
  };
  move(move_direction = this.going()){
    if (move_direction === '') return;
    this.hopped_from = this.tile();
    this.tile().remove_flan(this);
    switch(move_direction){
      case "N":
        this.y += 1;
        break;
      case "E":
        this.x += 1;
        break;
      case "W":
        this.x -= 1;
        break;
      case "S":
        this.y -= 1;
    }
    this.x = mod(this.x,this.board.width);
    this.y = mod(this.y,this.board.height);
    this.direction = move_direction;
    this.tile().flans.push(this);
  };
  move_to(x = this.x,y=this.y,direction = this.direction){
    this.tile().remove_flan(this);
    this.x = mod(x,this.board.width);
    this.y = mod(y,this.board.height);
    this.direction = direction;
    this.tile().flans.push(this);
  }
  neighbor_tiles(){
    let left_coords = this.local2absolute(-1,0);
    let right_coords = this.local2absolute(1,0);
    let front_coords = this.local2absolute(0,1);
    let back_coords = this.local2absolute(0,-1);
    var obj = {
      left: this.board.axes[left_coords.x][left_coords.y],
      right: this.board.axes[right_coords.x][right_coords.y],
      front: this.board.axes[front_coords.x][front_coords.y],
      back: this.board.axes[back_coords.x][back_coords.y]
    };
    return obj;
  }
  right(){
    return {"N":"E",
            "E":"S",
            "S":"W",
            "W":"N"}[this.direction]
  }
  left(){
    return {"N":"W",
            "W":"S",
            "S":"E",
            "E":"N"}[this.direction]
  }
  back(){
    return {"N":"S",
            "S":"N",
            "W":"E",
            "E":"W"}[this.direction]
  }
  going(){
    if (this.neighbor_tiles().front.floor === 'r'){
      return this.direction;
    } else if (this.neighbor_tiles().right.floor === 'r'){
      return this.right();
    } else if (this.neighbor_tiles().left.floor === 'r'){
      return this.left();
    }
    return '';
  }
  following(){
    var temp_flan = new Flan(this.board,this.x,this.y,this.direction);
    temp_flan.move();
    var test_tile = temp_flan.tile();
    var test_direction = temp_flan.going();
    temp_flan.deconstruct();
    return test_tile.flan_going(test_direction);
  }
  going_to_t(){
    var temp_flan = new Flan(this.board,this.x,this.y,this.direction);
    temp_flan.move();
    if (temp_flan.tile() === this.tile()){
      temp_flan.deconstruct();
      return false;
    }
    var temp_flan_neighbors = temp_flan.neighbor_tiles();
    var condition = (temp_flan_neighbors.front.floor === '' &&
                 temp_flan_neighbors.right.floor === 'r'&&
                 temp_flan_neighbors.left.floor === 'r');
    temp_flan.deconstruct();
    return condition;
  }
  flan_competing_for_t(){
    if (! this.going_to_t()) return false;
    var temp_flan = new Flan(this.board,this.x,this.y,this.direction);
    temp_flan.move();
    var ret_val = temp_flan.neighbor_tiles().left.flan_going(temp_flan.right());
    temp_flan.deconstruct();
    if (ret_val.has_stepped){
      return false;
    }
    return ret_val;
  }
  step(){
    if (this.has_stepped || this.stuck){return};
    let next_flan = this.following();
    if (next_flan === this){
      this.stuck = true;
      this.has_stepped = true;
      return;
    }
    if (this.looped){
      this.has_stepped = true;
      this.move();
      if (next_flan){
        next_flan.step();
      }
      return;
    }
    if (next_flan){
      if (next_flan.looped || next_flan.stuck){
        this.stuck = true;
        this.has_stepped = true;
        return;
      }
      if (next_flan.is_waiting){ // We found a new loop. Inform the others, then advance the whole loop.
        this.looped = true;
        let f = next_flan;
        while (f !== this){
          f.looped = true;
          f = f.following();
        }
        //next_flan.looped = true;
        this.move();
        this.has_stepped = true;
        next_flan.step();
        return;
      }
      this.is_waiting = true;
      next_flan.step(); //let the next flan get out of the way.
      this.is_waiting = false;
      if (this.following()){ //the flan we are following could not move, or another flan took its place. Stop.
        if (this.following.looped || this.following.stuck){
          this.stuck=true;
        }
        this.has_stepped = true;
        return;
      }
      if (this.flan_competing_for_t()){ //let another flan into the procession. Stop.
        this.flan_competing_for_t().step();
        this.has_stepped = true;
        return;
      }
      // we can fill the space we were following. Move and stop.
      this.move();
      this.has_stepped = true;
      return;
    }
    //we are not following anyone, i.e. our target space is open.
    if (this.flan_competing_for_t()){ //let another flan into the procession. Stop.
        this.flan_competing_for_t().step();
        this.has_stepped = true;
        return;
    }
    //we have priority for entering our target. Move and stop.
    this.move();
    this.has_stepped = true;
    return;
  }
  //This function gives the absolute coordinates of a 
  //space that is "right" spaces to the right and "ahead" spaces
  //ahead from the flan.
  local2absolute(right,ahead){
    var turns = {"N":0,
             "E":1,
             "S":2,
             "W":3}[this.direction];
    var shift = rotate(right,ahead,turns);
    var x = this.x + shift.x;
    var y = this.y + shift.y;
    x=mod(x,this.board.width);
    y=mod(y,this.board.height);
    var obj ={
      x:x,
      y:y
    };
    return obj;
  }
  //This function gives the local coordinates of a point (x,y)
  //in terms of the number of spaces "right" and "ahead" of the flan
  absolute2local(x,y){
    x=mod(x,this.board.width);
    y=mod(y,this.board.height);
    var shift={
      x: x-this.x,
      y: y-this.y
    };
    var turns = {"N":0,
             "E":1,
             "S":2,
             "W":3}[this.direction];
    var locals = rotate(shift.x,shift.y,-turns);
    var obj ={
      right:locals.x,
      ahead:locals.y
    };
    return obj;
  }
}


function mod(m,n){
  return (m%n + n)%n;
}

//This function rotates a vector (x,y) "n" steps clockwise.
function rotate(x,y,n){
  n = mod(n,4);
  for(var i=0;i<n;i++){
    var temp=y;
    y=-x;
    x=temp;
  }
  var obj = {
    x:x,
    y:y
  };
  return obj;
}

class House {
  constructor(board,i,j,direction, decorator = ""){
    this.board = board;
    this.tile = board.axes[i][j];
    this.direction = direction;
    this.decorator = decorator;
    this.flan = new Flan(board,i,j,direction);
    this.flan.decorator = decorator;
    this.board.houses.push(this);
    this.tile.houses.push(this);
  }
  appearance(){
    return "H"+this.decorator+arrows[this.direction];
  }
  recall_flan(){
    this.flan.move_to(this.tile.x,this.tile.y,this.direction);
    this.board.is_changed = true;
  }
  deconstruct(){
    this.flan.deconstruct();
    this.board.remove_house(this);
    this.tile.remove_house(this);
  }
  rotate(times = 1){
    for (var i=0; i<times; i++){
      this.direction = {"N":"E",
                        "E":"S",
                        "S":"W",
                        "W":"N"}[this.direction];
    }
    this.recall_flan();
  }
}

class Game_window {
  constructor(board) {
    this.board=board;
    this.canvas = document.getElementById("myCanvas");
    this.context = this.canvas.getContext("2d");
    this.tile_size = 60;
    this.shift = {x:this.tile_size * this.board.height * Math.sqrt(0.5),
                  y:20};
    this.canvas.addEventListener("click",this.my_click.bind(this));
    this.canvas.addEventListener("keydown",this.my_key_down.bind(this));
    this.canvas.addEventListener("keyup",this.my_key_up.bind(this));
    this.shift_speed = {x:0, y:0};
    this.keys = {up:false, down:false, left:false, right:false};
  }
  my_key_down(event){
    var key = event.key;
    var stepsize = 3;
    switch(key){
      case 'w':
      case 'W':
      case 'ArrowUp':
        if(!this.keys.up){
          this.keys.up = true;
          this.shift_speed.y+=stepsize;
        }
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        if(!this.keys.left){
          this.keys.left = true;
          this.shift_speed.x+=stepsize;
        }
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        if(!this.keys.down){
          this.keys.down = true;
          this.shift_speed.y-=stepsize;
        }
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        if(!this.keys.right){
          this.keys.right = true;
          this.shift_speed.x-=stepsize;
        }
        break;
    }
  }
  my_key_up(event){
    var key = event.key;
    switch(key){
      case 'w':
      case 'W':
      case 'ArrowUp':
        this.keys.up = false;
        this.shift_speed.y = 0;
        break;
      case 'a':
      case 'A':
      case 'ArrowLeft':
        this.keys.left = false;
        this.shift_speed.x = 0;
        break;
      case 's':
      case 'S':
      case 'ArrowDown':
        this.keys.down = false;
        this.shift_speed.y = 0;
        break;
      case 'd':
      case 'D':
      case 'ArrowRight':
        this.keys.right = false;
        this.shift_speed.x = 0;
        break;
    }
  }
  shift_step(){
    this.shift.x += this.shift_speed.x;
    this.shift.y += this.shift_speed.y;
  }
  my_click(event){
    var tile = this.tile_of(event.offsetX,event.offsetY);
    tile.on_click();
  }
  draw_floor_at(x,y){ // feed this grid coordinates, not canvas coordinates.
    this.context.drawImage(document.getElementById("grass"),
                           this.skewed_position_x(x,y)-this.tile_size*Math.sqrt(0.5),
                           this.skewed_position_y(x,y),
                           this.tile_size*Math.sqrt(2),
                           this.tile_size*Math.sqrt(0.5));
  }
  draw_road_at(x,y){
    var tile_x = mod(x,this.board.width);
    var tile_y = mod(y,this.board.height);
    if (this.board.axes[tile_x][tile_y].floor === '') return;
    this.context.drawImage(document.getElementById("road"),
                           this.skewed_position_x(x,y)-this.tile_size*Math.sqrt(0.5),
                           this.skewed_position_y(x,y),
                           this.tile_size*Math.sqrt(2),
                           this.tile_size*Math.sqrt(0.5));
  }
  skewed_position_x(x,y){
    return (this.shift.x)+( (this.tile_size * Math.sqrt(0.5))*(x+y+1-this.board.height) );
  }
  skewed_position_y(x,y){
    return (this.shift.y)+( (this.tile_size * Math.sqrt(0.5) * 0.5)*(x-y+this.board.height-1) );
  }
  skewed_position_inverse(x,y){
    var horizontal_half = this.tile_size * Math.sqrt(0.5);
    var vertical_half = horizontal_half * 0.5;
    var newx = x - (this.shift.x+horizontal_half * (1-this.board.height));
    var newy = y - (this.shift.y+vertical_half * (this.board.height-1));
    newx /= horizontal_half;
    newy /= vertical_half;
    var obj = {x:( newx+newy )/2,
               y:( newx-newy )/2+1}; // I don't know why this 1 belongs here.
    return obj;
  }
  tile_of(x,y){
    var reduced_coords = this.skewed_position_inverse(x,y);
    reduced_coords.x = Math.floor(reduced_coords.x);
    reduced_coords.y = Math.floor(reduced_coords.y);
    reduced_coords.x = mod(reduced_coords.x,this.board.width);
    reduced_coords.y = mod(reduced_coords.y,this.board.height);
    return this.board.axes[reduced_coords.x][reduced_coords.y];
  }
  clear(){
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  draw_flan_at(flan,x,y,fraction=1){
    var stack_separation = 10;
    var ctx = this.context;
    ctx.save();

    var new_x = x;
    var new_y = y;
    var new_coords = {
      x : this.skewed_position_x(new_x,new_y),
      y : this.skewed_position_y(new_x,new_y) - (stack_separation * flan.stack_position())
    };
    if (!flan.hopped_from || fraction >= 1) {
      var current_coords = new_coords;  
    } else {
      var old_x = x;
      var old_y = y;
      switch(flan.direction){
        case "N":
          old_y -= 1;
          break;
        case "S":
          old_y += 1;
          break;
        case "E":
          old_x -= 1;
          break;
        case "W":
          old_x += 1;
          break;
      }
      var old_coords = {
        x : this.skewed_position_x(old_x,old_y),
        y : this.skewed_position_y(old_x,old_y) - (stack_separation * flan.previous_stack_position) 
      };
      var current_coords = this.hop_path(old_coords,new_coords,fraction);
    }

    ctx.translate(current_coords.x,current_coords.y);
    switch(flan.direction){
      case "N":
        var hogimg = document.getElementById("up_right_hog");
        break;
      case "E":
        var hogimg = document.getElementById("down_right_hog");
        break;
      case "S":
        var hogimg = document.getElementById("down_left_hog");
        break;
      case "W":
        var hogimg = document.getElementById("up_left_hog");
        break;
    }
    ctx.drawImage(hogimg,- this.tile_size*0.4,-this.tile_size*0.2,this.tile_size*0.8,this.tile_size*0.8);
    ctx.restore();    
  }
  draw_flans_at(x,y,fraction = 1){
    var board_x = mod(x,this.board.width);
    var board_y = mod(y,this.board.height);
    var tile = this.board.axes[board_x][board_y];
    for(let flan of tile.flans){
      this.draw_flan_at(flan,x,y,fraction);
    }
  }
  draw_house_at(x,y){
    var board_x = mod(x, this.board.width);
    var board_y = mod(y, this.board.height);
    var house = this.board.axes[board_x][board_y].houses[0];
    if (house === undefined) return;
    
    switch(house.direction){
      case "N":
        var hole = document.getElementById("hole_up_right");
        break;
      case "E":
        var hole = document.getElementById("hole_down_right");
        break;
      case "S":
        var hole = document.getElementById("hole_down_left");
        break;
      case "W":
        var hole = document.getElementById("hole_up_left");
        break;
    }

    this.context.drawImage(hole,
                           this.skewed_position_x(x,y)-this.tile_size*Math.sqrt(0.5),
                           this.skewed_position_y(x,y),
                           this.tile_size*Math.sqrt(2),
                           this.tile_size*Math.sqrt(0.5));
  }
  hop_path(start,end,fraction){//feed this objects with x and y
    var jumpheight = 60;
    var obj ={
      x : start.x * (1 - fraction) + end.x * fraction,
      y : start.y * (1 - fraction) + end.y * fraction - jumpheight * fraction * (1 - fraction)
    }
    return obj;
  }
  do_everywhere_visible(myfun,fraction = 1){
    var first_coords = this.skewed_position_inverse(0,0);
    first_coords.x = Math.floor(first_coords.x);
    first_coords.y = Math.floor(first_coords.y);
    var row_length = 2 + Math.floor( this.canvas.width / (this.tile_size * Math.sqrt(2)) );
    var num_rows = 2 + Math.floor( this.canvas.height / (this.tile_size * Math.sqrt(0.5)) );
    for(var row = 0; row<num_rows; row++){
      for(var column = -1; column<row_length; column++){
        myfun.call(this,first_coords.x+row+column,first_coords.y-row+column+1,fraction);
      }
      for(var column = -1; column<row_length; column++){
        myfun.call(this,first_coords.x+row+column,first_coords.y-row+column  ,fraction);
      }
    }
  }
  draw_visible(fraction=1){
    this.clear();
    this.do_everywhere_visible(this.draw_floor_at);
    this.do_everywhere_visible(this.draw_road_at);
    this.do_everywhere_visible(this.draw_house_at);
    this.do_everywhere_visible(this.draw_flans_at,fraction*2);    
  }
}

$(document).ready(function(){

  b = new Board(7,6);

  b.axes[1][4].floor="r";
  b.axes[2][1].floor="r";
  b.axes[2][2].floor="r";
  b.axes[2][4].floor="r";
  b.axes[3][1].floor="r";
  b.axes[3][2].floor="r";
  b.axes[3][3].floor="r";
  b.axes[3][4].floor="r";
  h1 = new House(b,0,4,"E","1");
  h2 = new House(b,1,5,"S","2");
  h3 = new House(b,1,3,"N","3");
  h4 = new House(b,2,3,"N","4");

  b.render();
  setInterval(function(){
    b.next_frame();
  },10)
});



$(document).ready(function(){
    $("#reset").click(function(){
        b.reset_day();
        b.next_frame();
    });
    $("#rotate_house").click(function(){
        b.selected_tool = "rotate_house";
        b.update_tool_display();
    });
    $("#road_toggle").click(function(){
        b.selected_tool = "road_toggle";
        b.update_tool_display();
    });
    $("#house_toggle").click(function(){
        b.selected_tool = "house_toggle";
        b.update_tool_display();
    });
});

</script>

<body>
 <div id="board_container">
 </div>
 <div id="step_count">
 This day has gone on for 0 steps.
 </div>
 <div id="reset_button">
    <button id="reset"> Reset </button>
 </div>
 <div id="tools">
 Tools:
 <button id="rotate_house"> Rotate House </button>
 <button id="road_toggle"> Road Toggle </button>
 <button id="house_toggle"> House Toggle </button>
 </div>
 <div id="selected_tool">
 </div>

 <canvas id="myCanvas" width="600" height="400"
   style="border:1px solid #000000;" tabindex='1'> 
 </canvas> 
 
 <p hidden> resources:
 <img id="up_left_hog"    src=resources/groundhogs/up_left_hog.png>
 <img id="up_right_hog"   src=resources/groundhogs/up_right_hog.png>
 <img id="down_left_hog"  src=resources/groundhogs/down_left_hog.png>
 <img id="down_right_hog" src=resources/groundhogs/down_right_hog.png>
 <img id="grass" src=resources/grass.png>
 <img id="road" src=resources/road.png>
 <img id="hole_up_left"    src=resources/holes/hole_up_left.png>
 <img id="hole_up_right"   src=resources/holes/hole_up_right.png>
 <img id="hole_down_left"  src=resources/holes/hole_down_left.png>
 <img id="hole_down_right" src=resources/holes/hole_down_right.png>
 </p>

</body>

</html>
