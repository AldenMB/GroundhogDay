<!DOCTYPE html>
<html>
<head>
<title>Demo Hog Movement</title>
</head>

<style type="text/css">
td{
  color:white;
  background-color:black;
  width:2em;
  height:2em;
  text-align:center;
}
.road{
  background-color:darkred;
}
</style>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js">

</script>
<script type="text/javascript">

Tile = function Tile(board, x, y, floor){
  this.board = board;
  this.x = x;
  this.y = y;
  this.floor = floor;
  this.flans = [];
  this.appearance = function appearance(){
    var string='';
    for (let flan of this.flans){
      string+=flan.appearance();
    };
    return string;
  }
  this.remove_flan = function remove_flan(flan){
    var index = this.flans.indexOf(flan);
    if (index > -1) {
      this.flans.splice(index,1);
    };
  }
}

Board = function Board(width,height){
  this.width = width;
  this.height = height;
  this.axes = [...Array(height)].map(e => Array(width).fill(''));
  for(var i=0;i<width;i++){
    for(var j=0;j<height;j++){
      this.axes[i][j]= new Tile(this,i,j,'');
    }
  }
}

Board.prototype.render = function render(){
  var board_container = $("#board_container")
  var board_table = $("<table>")
  for (var i=this.height-1;i>=0;i--){
    var tr = $("<tr>")
    for (var j=0;j<this.width;j++){
      var td = $("<td>")
      if (this.axes[j][i].floor === "r") {
        td.addClass("road")
      }
      td.text(this.axes[j][i].appearance());

      clickhandlerfactory = function(i,j,board){
        return function(){
          if(board.axes[j][i].floor === 'r'){
            board.axes[j][i].floor = '';
          } else if (board.axes[j][i].floor === ''){
            board.axes[j][i].floor = 'r'
          }
        }
      }
      td.bind("click",clickhandlerfactory(i,j,this))
      tr.append(td)
    }
    board_table.append(tr)
  }
  board_container.empty()
  board_container.append(board_table)
}


arrows = {
  "N":"↑",
  "E":"→",
  "W":"←",
  "S":"↓"
}

Flan = function Flan(board,x,y,direction){
  this.x = x;
  this.y = y;
  this.direction = direction;
  this.board = board;
  this.tile = function tile(){
    return this.board.axes[this.x][this.y];
  }
  this.tile().flans.push(this);
  this.appearance = function appearance(){
    return arrows[this.direction];
  };
  this.move = function move(move_direction){
    this.board.axes[this.x][this.y].remove_flan(this);
    switch(move_direction){
      case "N":
        this.y += 1;
        break;
      case "E":
        this.x += 1;
        break;
      case "W":
        this.x -= 1;
        break;
      case "S":
        this.y -= 1;
    }
    this.x = mod(this.x,this.board.width);
    this.y = mod(this.y,this.board.height);
    this.direction = move_direction;
    this.tile().flans.push(this);
  };
  this.neighbor_tiles = function neighbor_tiles(){
    left_coords = this.local2absolute(-1,0);
    right_coords = this.local2absolute(1,0);
    front_coords = this.local2absolute(0,1);
    back_coords = this.local2absolute(0,-1);
    var obj = {
      left: this.board.axes[left_coords.x][left_coords.y],
      right: this.board.axes[right_coords.x][right_coords.y],
      front: this.board.axes[front_coords.x][front_coords.y],
      back: this.board.axes[back_coords.x][back_coords.y]
    };
    return obj;
  }
  this.right = function right(){
    return {"N":"E",
            "E":"S",
            "S":"W",
            "W":"N"}[this.direction]
  }
  this.left = function left(){
    return {"N":"W",
            "W":"S",
            "S":"E",
            "E":"N"}[this.direction]
  }
  this.back = function back(){
    return {"N":"S",
            "S":"N",
            "W":"E",
            "E":"W"}[this.direction]
  }
}

function mod(m,n){
  return (m%n + n)%n;
}

//Since there are many times when a flan needs to 
//work in its own coordinate system, it makes sense
//to have a function to translate.

//I want to be able to rotate a vector.
//This function rotates a vector (x,y) "n" steps clockwise.
function rotate(x,y,n){
  n = mod(n,4);
  for(var i=0;i<n;i++){
    var temp=y;
    y=-x;
    x=temp;
  }
  var obj = {
    x:x,
    y:y
  };
  return obj;
}

//This function gives the absolute coordinates of a 
//space that is "right" spaces to the right and "ahead" spaces
//ahead from the flan.
Flan.prototype.local2absolute = function local2absolute(right,ahead){
  var turns = {"N":0,
           "E":1,
           "S":2,
           "W":3}[this.direction];
  var shift = rotate(right,ahead,turns);
  var x = this.x + shift.x;
  var y = this.y + shift.y;
  x=mod(x,this.board.width);
  y=mod(y,this.board.height);
  var obj ={
    x:x,
    y:y
  };
  return obj;
}

//This function gives the local coordinates of a point (x,y)
//in terms of the number of spaces "right" and "ahead" of the flan
Flan.prototype.absolute2local = function absolute2local(x,y){
  x=mod(x,this.board.width);
  y=mod(y,this.board.height);
  var shift={
    x: x-this.x,
    y: y-this.y
  };
  var turns = {"N":0,
           "E":1,
           "S":2,
           "W":3}[this.direction];
  var locals = rotate(shift.x,shift.y,-turns);
  var obj ={
    right:locals.x,
    ahead:locals.y
  };
  return obj;
}

/*
Flan.prototype.step = function step(){
  adjacents = [[mod(this.x+1,this.board.width),this.y],
               [this.x,mod(this.y-1,this.board.height)],
               [mod(this.x-1,this.board.width),this.y],
               [this.x,mod(this.y+1,this.board.height)]];

  forwardindex = {"E":0,
                  "S":1,
                  "W":2,
                  "N":3}[this.direction]
  
  adjacents.push.apply(adjacents, adjacents.splice(0,forwardindex))

  for (var i=0;i<4;i++){
    if (i === 2) {
      continue;
    }
    var newx = adjacents[i][0];
    var newy = adjacents[i][1];
    if (this.board.axes[newx][newy].floor === 'r'){
      this.move(
        {0:"E",
         1:"S",
         2:"W",
         3:"N"}[mod(i+forwardindex,4)]
      )
      /*
      this.board.axes[this.x][this.y].remove_flan(this);
      this.x = newx;
      this.y = newy;
      this.board.axes[newx][newy].flans.push(this);
      this.direction = {0:"E",
                        1:"S",
                        2:"W",
                        3:"N"}[mod(i+forwardindex,4)];
      *//*
      break;
    }
  }
}
*/

Flan.prototype.dumb_step = function dumb_step(){
  neighbors = this.neighbor_tiles();
  if (neighbors.front.floor === 'r'){
    this.move(this.direction);
  } else if (neighbors.right.floor === 'r'){
    this.move(this.right());
  } else if (neighbors.left.floor === 'r'){
    this.move(this.left())
  }
}

b = new Board(5,6);

b.axes[2][1].floor="r";
b.axes[3][2].floor="r";
b.axes[4][2].floor="r";
b.axes[4][1].floor="r";
b.axes[0][1].floor="r";
b.axes[1][1].floor="r";
b.axes[1][3].floor="r";
b.axes[1][4].floor="r";
b.axes[2][3].floor="r";
b.axes[2][4].floor="r";
b.axes[2][2].floor="r";

f = [];
f[0] = new Flan(b,2,2,"N");
f[1] = new Flan(b,2,1,"W");
f[2] = new Flan(b,1,4,"E");
f[3] = new Flan(b,1,4,"E");

setInterval(function(){
  for (var i=0 ; i<f.length ; i++) {
    f[i].dumb_step();
  }
  b.render();
  },500)



</script>

<body>
 <div id="board_container">

 </div>
</body>

</html>
